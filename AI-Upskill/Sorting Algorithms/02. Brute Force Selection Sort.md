### Brute Force
- Simple Design Strategy
- Most straight forward approach
- Usually based on problem statement
- Input: unordered sequence
- Output: ordered sequence
#### Algorithm
Ascending order sorting
- Locate the smallest item and put it in first place
- Select the next smallest item and put it in second place and so on ..
- Sorting by repeated selection: *"Selection Sort"*
- Final output ordering generated one by one in sequence

**Example**

| i   | min | 0     | 1     | 2     | 3   | 4     | 5   | 6     | 7   | 8   | 9     | 10    |
| --- | --- | ----- | ----- | ----- | --- | ----- | --- | ----- | --- | --- | ----- | ----- |
|     |     | S     | O     | R     | T   | E     | X   | A     | M   | P   | L     | E     |
| 0   | 6   | S     | O     | R     | T   | E     | X   | ==A== | M   | P   | L     | E     |
| 1   | 4   | **A** | O     | R     | T   | ==E== | X   | S     | M   | P   | L     | E     |
| 2   | 10  | **A** | **E** | R     | T   | 0     | X   | S     | M   | P   | L     | ==E== |
| 3   | 9   | **A** | **E** | **E** | T   | 0     | X   | S     | M   | P   | ==L== | R     |
and so on ..

#### Pseudocode
Input: Array A of size n
Output: Sorted A

```
Function SelectionSort(A):
  for i in 0 to n-1:
    minValue = A[i]
      for redIndex in i+1 to n-1:
	  if A[red] < minValue:
	    minValue = A[red]
	    minIndex = redIndex
    swap(A[i], A[redIndex])
  return A
```

##### Complexity Analysis


#upskill #aiml #sorting #algorithms #Selection-Sort
